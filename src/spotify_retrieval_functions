"""
Spotify Global Trends Function Library

This module provides utility functions for spotify global trends including data loading, data
cleaning and filtering, SQLite Database, query and analysis, and display/reporting. 

Team Members: Vivian Dao, Fatimah Shaw, Christiana Crabbe, Vince Baluis
Course: Object-Oriented Programming for Information Science
"""

# =============================================================================
# Data Loading
# =============================================================================

import os
import pandas as pd
import sqlite3

def get_top_50_songs_by_countries(csv_filename, country_list):
    """
    Reads a CSV file and returns the top 50 songs for each country in country_list.
    Filters for the columns: Country, Rank, Title, and Artists.

    Args:
        csv_filename (str): Name of the CSV file.
        country_list (list): List of country names (e.g., ['Spain', 'France']).

    Returns:
        dict: Dictionary where keys are country names and values are DataFrames
              containing the top 50 songs for each country.
    """
    script_dir = os.path.dirname(os.path.abspath(__file__))
    csv_path = os.path.join(script_dir, csv_filename)
    
    df = pd.read_csv(csv_path)
    
    results = {}

    for country in country_list:
        country_df = df[df['Country'].str.lower() == country.lower()].copy()

        country_df = country_df[['Country', 'Rank', 'Title', 'Artists','Genre']]

        country_df['Rank'] = pd.to_numeric(country_df['Rank'], errors='coerce')
        top_50 = country_df.sort_values('Rank').head(50)

        results[country] = top_50

    return results

def load_and_validate_csv(file_path):
    """
    Loads a CSV file into a pandas DataFrame and validates its structure.
    Args: file_path (str): Path to the CSV file.
    Returns: pd.DataFrame: DataFrame containing the CSV data if valid, else None.
    """
    try:
        df = pd.read_csv(file_path)
        required_columns = {'Country', 'Rank', 'Title', 'Artists', 'Genre'}
        if not required_columns.issubset(df.columns):
            raise ValueError(f"CSV file must contain the following columns: {required_columns}")
        return df
    except FileNotFoundError:
        print(f"Error: The file at {file_path} was not found.")
        return None
    except pd.errors.EmptyDataError:
        print("Error: The CSV file is empty.")
        return None
    except pd.errors.ParserError:
        print("Error: There was a problem parsing the CSV file.")
        return None
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return None

def organize_track_title(title):
"""
Cleans each track title by removing extra spaces and characters thaat are not letters or numbers

Args:
    title(str): This is the title of the song listed in the dataset.

Returns:
    str: a more organized and updated version of the title.

Example:
    >>> organize_track_title("Happy???    Birthday 100)
    'Happy Birthday 100'
"""
    title = title.strip()
    useable_char = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 "
    updated_title = ""

    for char in title:
        if char in useable_char:
            updated_title = updated_title + char
    return updated_title

def count_tracks(df):
"""
Counts the number of tracks (songs) that are present in the dataset.

Args:
    df(DataFrame): The dataset to keep track of the number of songs.

Returns:
    int: The total number of songs.

Example:
    >>> count_tracks(df)
    50
"""
    total_num_tracks = 0
    for i in range(len(df)):
        total_num_tracks +=1
    return total_num_tracks

def filter_country(df, country):
"""
Filters the dataset by returning rows for a specific country.

Args:
    df(DataFrame): The dataset that is being filtered.
    country (str): The country name being analyzed.

Returns:
    Dataframe: An updated dataset that only lists information for the specifc country that was filtered.
    Example:
        >>> filter_country(df, "South Africa")
"""
    country = country.strip()
    updated_dataset = df[df["Country"] == country]
    return updated_dataset

def create_and_connect_db(db_path: str) -> sqlite3.Connection:
    """
    Creates (if not exists) and connects to an SQLite database.

    Args:
        script_dir (str): Directory path where the script is located.
        db_filename (str): SQLite database filename (e.g., 'spotify_top.db').

    Returns:
        sqlite3.Connection: Active SQLite connection object.
    """
    db_path = os.path.join(script_dir, db_filename)
    os.makedirs(os.path.dirname(db_path), exist_ok=True)

    conn = sqlite3.connect(db_path)
    return conn

def save_dataframe_to_sqlite(df: pd.DataFrame, conn: sqlite3.Connection, table_name: str, if_exists: str = "replace"):
    """
    Saves a pandas DataFrame into an SQLite database using an active connection.

    Args:
        df (pd.DataFrame): The DataFrame to save.
        conn (sqlite3.Connection): Active SQLite connection.
        table_name (str): Name of the table to create or append to.
        if_exists (str): What to do if the table already exists.
                         Options: 'fail', 'replace', 'append'. Default = 'replace'.

    Raises:
        ValueError: If the DataFrame is empty.
        sqlite3.DatabaseError: If thereâ€™s an issue writing to the database.
    """
    if df.empty:
        raise ValueError(f"DataFrame for table '{table_name}' is empty. Nothing to save.")

    try:
        df.to_sql(table_name, conn, if_exists=if_exists, index=False)
    except sqlite3.DatabaseError as e:
        raise sqlite3.DatabaseError(f"Failed to save DataFrame to '{table_name}': {e}")

if __name__ == "__main__":


    top_50_by_country = get_top_50_songs_by_countries(
        "SpotifyTopSongsByCountry - May 2020.csv",
        ["Spain", "South Africa", "Japan", "United States"]
    )
    script_dir = os.path.dirname(os.path.abspath(__file__))
    db_filename = "Spotify_Top_Tracks_Queries.db"
    for country, df in top_50_by_country.items():
        print(f"\nTop 50 Songs in {country}:\n")
        print(df)
        onn = create_and_connect_db(os.path.join(script_dir, db_filename))
        save_dataframe_to_sqlite(country_df, conn, table_name="Top_Tracks_Per_Country", if_exists="replace")














